<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用Charles对Https请求进行抓包(针对Android模拟器)]]></title>
      <url>http://yoursite.com/2016/09/03/tools01/</url>
      <content type="html"><![CDATA[<p>使用Charles来进行请求抓包</p>
<h3 id="1-安装charles-ca证书"><a href="#1-安装charles-ca证书" class="headerlink" title="1.安装charles ca证书"></a>1.安装charles ca证书</h3><p><img src="http://blog-10057188.cos.myqcloud.com/tools01.png" alt=""><br><img src="http://blog-10057188.cos.myqcloud.com/tools02.png" alt=""><br><img src="http://blog-10057188.cos.myqcloud.com/tools03.png" alt=""></p>
<h3 id="2-设置Wifi代理"><a href="#2-设置Wifi代理" class="headerlink" title="2.设置Wifi代理"></a>2.设置Wifi代理</h3><p><img src="http://blog-10057188.cos.myqcloud.com/tools04.png" alt=""></p>
<h3 id="3-https设置"><a href="#3-https设置" class="headerlink" title="3.https设置"></a>3.https设置</h3><p>模拟器浏览器中代开(使用原生浏览器)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chls.pro/ssl</span><br></pre></td></tr></table></figure></p>
<p><img src="http://blog-10057188.cos.myqcloud.com/tools05.png" alt=""></p>
<h3 id="4-在Charles中开启需要解析的https请求"><a href="#4-在Charles中开启需要解析的https请求" class="headerlink" title="4.在Charles中开启需要解析的https请求"></a>4.在Charles中开启需要解析的https请求</h3><p><img src="http://blog-10057188.cos.myqcloud.com/tools06.png" alt=""></p>
<h3 id="5-重启Charles和模拟器-可选操作-建议重启"><a href="#5-重启Charles和模拟器-可选操作-建议重启" class="headerlink" title="5.重启Charles和模拟器(可选操作,建议重启)"></a>5.重启Charles和模拟器(可选操作,建议重启)</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP 协议入门]]></title>
      <url>http://yoursite.com/2016/08/20/it01/</url>
      <content type="html"><![CDATA[<p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。<br>本文介绍 HTTP 协议的历史演变和设计思路。</p>
<p><img src="http://blog-10057188.cos.myqcloud.com/it01.jpg" alt=""></p>
<h3 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP/0.9"></a>一、HTTP/0.9</h3><p>   HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。<br>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。<br>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h3 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP/1.0"></a>二、HTTP/1.0</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>  1996年5月，HTTP/1.0 版本发布，内容大大增加。<br>  首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。<br>  其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。<br>  再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。<br>  其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h4 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h4><p>  下面是一个1.0版的HTTP请求的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，这个格式与0.9版有很大变化。<br> 第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p>
<h4 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h4><p>  服务器的回应如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"> </span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p> 回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h4 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h4><p>  关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p>
<p> 下面是一些常见的<code>Content-Type</code>字段的值。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">text/plain</span><br><span class="line">text/html</span><br><span class="line">text/css</span><br><span class="line">image/jpeg</span><br><span class="line">image/png</span><br><span class="line">image/svg+xml</span><br><span class="line">audio/mp4</span><br><span class="line">video/mp4</span><br><span class="line">application/javascript</span><br><span class="line">application/pdf</span><br><span class="line">application/zip</span><br><span class="line">application/atom+xml</span><br></pre></td></tr></table></figure></p>
<p> 这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p>
<p> 除了预定义的类型，厂商也可以自定义类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure>
<p> 上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p> <code>MIME type</code>还可以在尾部使用分号，添加参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p> 上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p> 客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p> 上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<p> <code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h4><p> 由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure>
<p> 客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h4 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h4><p> HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br> TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br> 为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p> 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p> 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h3 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP/1.1"></a>三、HTTP/1.1</h3><p>  1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<h4 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h4><p>  1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。<br>  客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p> 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h4 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h4><p>  1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。<br>  举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h4 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h4><p>  一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure>
<p> 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p>
<p> 在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<h4 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h4><p>  使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。<br>  对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。<br>  因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>
<p> 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"> </span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"> </span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"> </span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"> </span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"> </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h4><p>  1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。<br>  另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
<p> 有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h4 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h4><p>  虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。<br>  为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h3 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h3><p>  2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>  这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>
<h3 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP/2"></a>五、HTTP/2</h3><p>  2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>
<h4 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h4><p>  HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。<br>  二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h4 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h4><p>  HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。<br>  举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>  这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h4 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h4><p>  因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>  HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>  数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM帧</code>），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>  客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h4 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h4><p>  HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>  HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h4 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h4><p>  HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。<br>  常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高效清晰Layout布局文件的一些技巧]]></title>
      <url>http://yoursite.com/2016/08/08/android01/</url>
      <content type="html"><![CDATA[<p>当人们谈论Android性能的时候总是习惯讨论怎么写出清晰高效的Java代码,却忽略了layout布局文件。layout布局缓慢的渲染速度对app性能也有的很大的影响。充满不必要的views和可读性差的layout文件会让你的app运行缓慢。在本文中我会分享5个技巧来帮你写出高效清晰的layout布局文件。</p>
<h3 id="1-用TextView本身的属性同时显示图片和文字"><a href="#1-用TextView本身的属性同时显示图片和文字" class="headerlink" title="1.用TextView本身的属性同时显示图片和文字"></a>1.用TextView本身的属性同时显示图片和文字</h3><p>通常你需要在文本旁边添加一张图片，假设你需要添加图片在文字的左边，像下面这样：<br><img src="http://blog-10057188.cos.myqcloud.com/android01.png" alt=""></p>
<p>不少人首先想到的就是用一个LinearLayout或RelativeLayou来包含一个TextView和ImageView,最后你用了三个UI元素和一大坨代码。用TextView的compound drawable是一个更好更清晰的解决方案。你只需要一个属性就可以搞定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;@string/batman&quot;</span><br><span class="line">        android:drawableLeft=&quot;@drawable/batman&quot;</span><br><span class="line">        android:drawableStart=&quot;@drawable/batman&quot;</span><br><span class="line">        android:drawablePadding=&quot;5dp&quot;&gt;</span><br><span class="line">&lt;/TextView&gt;</span><br></pre></td></tr></table></figure></p>
<p>用到的主要属性：</p>
<p>drawableLeft- 指定drawable放在文本的左边</p>
<p>drawableStart- 作用和drawableLeft相同但是它基于新的API(android 4.2)支持RTL</p>
<p>drawablePadding- 指定文本和drawable之间padding</p>
<h3 id="2-同时使用ImageView的src和background属性实现点击效果"><a href="#2-同时使用ImageView的src和background属性实现点击效果" class="headerlink" title="2.同时使用ImageView的src和background属性实现点击效果"></a>2.同时使用ImageView的src和background属性实现点击效果</h3><p>你应该同时使用它们，在很多情况下你会想要给ImageView添加点击效果，然后我看到很多人用LinearLayout来包裹一个ImageView来实现。添加另一个view是没必要的。下面的代码可以让你做的更好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/image&quot;</span><br><span class="line">        android:layout_width=&quot;@dimen/batman_logo_width&quot;</span><br><span class="line">        android:layout_height=&quot;@dimen/batman_logo_height&quot;</span><br><span class="line">        android:background=&quot;?attr/selectableItemBackground&quot;//点击效果</span><br><span class="line">        android:src=&quot;@drawable/batman_logo_transparent&quot;//图片</span><br><span class="line">        style=&quot;@style/logo_image_style&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>显示图片用”src”属性，drawable selector 图片点击效果用”background”属性实现，上面用的是android默认提供的selector,当然你也可以换成你自己实现的。</p>
<h3 id="3-用LinearLayout自带的分割线"><a href="#3-用LinearLayout自带的分割线" class="headerlink" title="3.用LinearLayout自带的分割线"></a>3.用LinearLayout自带的分割线</h3><p>分割线在app经常会用到的，使用频率高到让你惊讶。但是LinearLayout有一个属性可以帮你添加分割线。下面的例子中，LinearLayout包含2个TextView和基于他们中间的分割线。<br><img src="http://blog-10057188.cos.myqcloud.com/android03.png" alt=""></p>
<h4 id="3-1-Create-divider-shape-创建shape"><a href="#3-1-Create-divider-shape-创建shape" class="headerlink" title="3.1 Create divider shape(创建shape)"></a>3.1 Create divider shape(创建shape)</h4><p>下面是一个简单的shape divider_horizontal.xml用来当做分割线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;size android:width=&quot;@dimen/divider_width&quot;/&gt;</span><br><span class="line">    &lt;solid android:color=&quot;@color/colorPrimaryDark&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2Add-shape-to-LinearLayout"><a href="#3-2Add-shape-to-LinearLayout" class="headerlink" title="3.2Add shape to LinearLayout"></a>3.2Add shape to LinearLayout</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:orientation=&quot;horizontal&quot;</span><br><span class="line">              android:background=&quot;@android:color/white&quot;</span><br><span class="line">              android:divider=&quot;@drawable/divider_horizontal&quot;  //添加分割线</span><br><span class="line">              android:dividerPadding=&quot;5dp&quot; //设置padding</span><br><span class="line">              android:showDividers=&quot;middle&quot;&gt;//居中显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView android:layout_width=&quot;0dp&quot;</span><br><span class="line">              android:layout_weight=&quot;0.5&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:gravity=&quot;center&quot;</span><br><span class="line">              style=&quot;@style/Text.Title&quot;</span><br><span class="line">              android:text=&quot;@string/batman_name&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView android:layout_width=&quot;0dp&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:layout_weight=&quot;0.5&quot;</span><br><span class="line">              android:gravity=&quot;center&quot;</span><br><span class="line">              style=&quot;@style/Text.Title&quot;</span><br><span class="line">              android:text=&quot;@string/superman_name&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>上面用到了三个xml属性：</p>
<p>divider -用来定义一个drawable或者color作为分割线</p>
<p>showDividers -指定分割线在哪里显示，它们可以显示在开始位置，中间，末尾或者选择不显示</p>
<p>dividerPadding -给divider添加padding</p>
<h3 id="4-使用Space控件"><a href="#4-使用Space控件" class="headerlink" title="4.使用Space控件"></a>4.使用Space控件</h3><p>当你需要在2个UI控件添加间距的时候,你可能会添加padding或margin。有时最终的layout文件是非常混乱，可读性非常差。当你需要解决问题时，你突然意识到这里有一个5dp的paddingTop,那里有一个2dp的marginBottom,还有一个4dp的paddingBottom在第三个控件上然后你很难弄明白到底是哪个控件导致的问题。还有我发现有些人在2个控件之间添加LinearLayout或View来解决这个问题，看起来是一个很简单解决方案但是对App的性能有很大的影响。</p>
<p>这里有一个更简单更容易的方法那就是Space,看下官方的文档：“Space is a lightweight View subclass that may be used to create gaps between components in general purpose layouts.” 他们没有说谎，确实很轻量。如果你看过Space的实现会发现Space继承View但是没有绘制任何东西在canvas。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Draw nothing.</span><br><span class="line"> *</span><br><span class="line"> * @param canvas an unused parameter.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法很简单，看下面的图片，我们想要在在标题和描述之间添加间距。<br><img src="http://blog-10057188.cos.myqcloud.com/android04.png" alt=""></p>
<p>你只需要简单的在2个TextView之间添加一个Space就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          style=&quot;@style/Text.Title&quot;</span><br><span class="line"></span><br><span class="line">&lt;Space android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;10dp&quot;/&gt;//添加间距</span><br><span class="line"></span><br><span class="line">&lt;TextView android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          android:text=&quot;@string/gotham_city_description&quot;</span><br><span class="line">          style=&quot;@style/Text.Details&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-使用和标签"><a href="#5-使用和标签" class="headerlink" title="5.使用和标签"></a>5.使用<include>和<merge>标签</merge></include></h3><p>重用布局是一个保持app一致的好方法，这样以后有改变的话只要改一个文件就可以了，Android提供了<include>标签帮你重用布局。</include></p>
<p>例如你现在决定创建有一个logo图片居中的酷炫Toolbar工具栏，然后你想要添加到每个页面中<br>下面是batman_toolbar.xml代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">        android:background=&quot;?attr/colorPrimary&quot;</span><br><span class="line">        android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;ImageView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height=&quot;@dimen/batman_logo_height&quot;</span><br><span class="line">               android:layout_gravity=&quot;center&quot;</span><br><span class="line">               android:src=&quot;@drawable/batman_logo_transparent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v7.widget.Toolbar&gt;</span><br></pre></td></tr></table></figure></p>
<p>你可以复制粘贴这些代码到每个Activity,但是不要这么做，在编程中有一个重要的规则：当你复制粘贴，那你就是在做错误的事。在这种情况下你可以用<include>标签在多个界面重用这个布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">        android:background=&quot;@android:color/white&quot;</span><br><span class="line">        tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include layout=&quot;@layout/batman_toolbar&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></include></p>
<p>用<include>标签你可以只用一行代码在app的每个页面添加你的toolbar,任何改变都会自动更新到所有页面。</include></p>
<p>除了<include>,<merge>也常用来从你的view层次结构中减不必要的view，它会移除没必要的嵌套的layouts，例如，如果被包含布局文件的根是一个LinearLayout,然后你把它include包含在另外一个LinearLayout里面，2个嵌套的LinearLayouts是没有必要的，这个嵌套的layout没有任何作用除了影响UI性能。在这种情况下可以用<merage \="">来替换被包含布局的根LinarLayout 移除不必要的view.</merage></merge></include></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[配置SSH keys]]></title>
      <url>http://yoursite.com/2016/07/07/git01/</url>
      <content type="html"><![CDATA[<h3 id="1-开始菜单Git-Bash-Window环境"><a href="#1-开始菜单Git-Bash-Window环境" class="headerlink" title="1 开始菜单Git Bash(Window环境)"></a>1 开始菜单Git Bash(Window环境)</h3><p><img src="http://blog-10057188.cos.myqcloud.com/git01.png" alt=""></p>
<h3 id="2-鼠标右键打开Git-Bash-Window环境"><a href="#2-鼠标右键打开Git-Bash-Window环境" class="headerlink" title="2 鼠标右键打开Git Bash(Window环境)"></a>2 鼠标右键打开Git Bash(Window环境)</h3><p><img src="http://blog-10057188.cos.myqcloud.com/git02.jpg" alt=""></p>
<h3 id="3-如果没有安装ssh，那么使用下面的指令"><a href="#3-如果没有安装ssh，那么使用下面的指令" class="headerlink" title="3 如果没有安装ssh，那么使用下面的指令"></a>3 如果没有安装ssh，那么使用下面的指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure>
<h3 id="4-检查SSH公钥-看看存不存在-ssh"><a href="#4-检查SSH公钥-看看存不存在-ssh" class="headerlink" title="4 检查SSH公钥 看看存不存在.ssh"></a>4 检查SSH公钥 看看存不存在.ssh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<h3 id="5-生成SSH公钥"><a href="#5-生成SSH公钥" class="headerlink" title="5 生成SSH公钥"></a>5 生成SSH公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>
<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」<br>然后系统会要你输入密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br></pre></td></tr></table></figure></p>
<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。<br>最后看到这样的界面，就成功设置ssh key了：<br><img src="http://blog-10057188.cos.myqcloud.com/git03.jpg" alt=""></p>
<h3 id="6-获取SSH-Key-现在你可以看到，在自己的目录下，有一个-ssh目录，说明成功了"><a href="#6-获取SSH-Key-现在你可以看到，在自己的目录下，有一个-ssh目录，说明成功了" class="headerlink" title="6 获取SSH Key,现在你可以看到，在自己的目录下，有一个.ssh目录，说明成功了"></a>6 获取SSH Key,现在你可以看到，在自己的目录下，有一个.ssh目录，说明成功了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>或者直接去目录下打开文件</p>
<h3 id="7-测试是否生效"><a href="#7-测试是否生效" class="headerlink" title="7 测试是否生效"></a>7 测试是否生效</h3><p>使用下面的命令测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>如果是下面的反馈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>输入yes就好，然后会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Mac OS X中开启或关闭显示隐藏文件]]></title>
      <url>http://yoursite.com/2016/07/04/mac01/</url>
      <content type="html"><![CDATA[<h3 id="如何在Mac-OS中开启或关闭显示隐藏文件命令"><a href="#如何在Mac-OS中开启或关闭显示隐藏文件命令" class="headerlink" title="如何在Mac OS中开启或关闭显示隐藏文件命令"></a>如何在Mac OS中开启或关闭显示隐藏文件命令</h3><ol>
<li>打开终端，输入：</li>
<li><p>此命令显示隐藏文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$: defaults write com.apple.finder AppleShowAllFiles -bool true</span><br></pre></td></tr></table></figure>
</li>
<li><p>此命令关闭显示隐藏文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$: defaults write com.apple.finder AppleShowAllFiles -bool false</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令运行之后需要重新加载Finder：快捷键option+command+esc，选中Finder，重新启动即可</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给博客系统绑定域名]]></title>
      <url>http://yoursite.com/2016/07/02/hexo01/</url>
      <content type="html"><![CDATA[<h3 id="域名配置错误了一直调整到现在"><a href="#域名配置错误了一直调整到现在" class="headerlink" title="域名配置错误了一直调整到现在"></a>域名配置错误了一直调整到现在</h3><h4 id="发帖纪念一下这个点还在码砖的攻城狮们-真爱生命-早睡早起-除非失眠-敲敲代码-看看书"><a href="#发帖纪念一下这个点还在码砖的攻城狮们-真爱生命-早睡早起-除非失眠-敲敲代码-看看书" class="headerlink" title="发帖纪念一下这个点还在码砖的攻城狮们,真爱生命,早睡早起(除非失眠,敲敲代码,看看书)"></a>发帖纪念一下这个点还在码砖的攻城狮们,真爱生命,早睡早起(除非失眠,敲敲代码,看看书)</h4><h1 id="现在说一下GitHub-Pages的空间域名绑定"><a href="#现在说一下GitHub-Pages的空间域名绑定" class="headerlink" title="现在说一下GitHub Pages的空间域名绑定"></a>现在说一下GitHub Pages的空间域名绑定</h1><ul>
<li>在项目source的目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如6love1.com。(不用www)</li>
<li><p>然后命令行运行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;hexo generate</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置申请的自定义域名的DNS设置</p>
<ol>
<li><p>查找IP地址对应的IP地址 <a href="https://help.github.com/articles/setting-up-an-apex-domain/" target="_blank" rel="external">https://help.github.com/articles/setting-up-an-apex-domain/</a><br><img src="http://blog-10057188.cos.myqcloud.com/hexo02.png" alt=""></p>
</li>
<li><p>域名配置中添加A类记录和CNAME记录<br><img src="http://blog-10057188.cos.myqcloud.com/hexo01.png" alt=""></p>
</li>
</ol>
</li>
</ul>
<h2 id="恭喜大功告成-属于自己的静态博客系统已经有了自定义域名"><a href="#恭喜大功告成-属于自己的静态博客系统已经有了自定义域名" class="headerlink" title="恭喜大功告成,属于自己的静态博客系统已经有了自定义域名"></a>恭喜大功告成,属于自己的静态博客系统已经有了自定义域名</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu在Vmware中自动适配屏幕]]></title>
      <url>http://yoursite.com/2016/06/18/ubuntu01/</url>
      <content type="html"><![CDATA[<p>解决方法:发现没有装VMware Tools</p>
<p>安装VMware Tools步骤</p>
<ol>
<li>点击菜单栏，虚拟机 → 安装VMware工具 → Install</li>
<li>这样会弹出一个包VMwareTools-<strong><em>*</em></strong>.tar.gz</li>
<li><p>将VMwareTools-9.6.0-1294478.tar.gz 复制到一个文件夹<br>解压，用tar xzf VMwareTools-9.6.0-1294478.tar.gz 命令行<br>得到文件夹vmware-tools-distrib</p>
<p>或者 右击 提取到此处 </p>
</li>
<li>命令行进入文件夹vmware-tools-distrib,再使用sudo ./vmware-install.pl安装即可</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo的使用方法]]></title>
      <url>http://yoursite.com/2016/06/15/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>图标 <a href="http://www.yeahzan.com/fa/facss.html" target="_blank" rel="external">http://www.yeahzan.com/fa/facss.html</a></p>
]]></content>
    </entry>
    
  
  
</search>
